//
// Created by 王智杰 on 2025/6/14.
//
//38.旅行售货员问题（回溯、分支限界）
//
//Description
//旅行售货员问题又称TSP问题，问题如下：某售货员要到若干个城市推销商品，已知各城市之间的路程（或旅费），他要选定一条从驻地出发，
// 经过每个城市一遍最后回到驻地的路线，使总的路线（或总的旅费）最小。
//数学模型为给定一个无向图，求遍历每一个顶点一次且仅一次的一条回路，最后回到起点的最小花费。
//Input
//输入的第一行为测试样例的个数T，接下来有T个测试样例。
//每个测试样例的第一行是无向图的顶点数n、边数m（ 1 < n ≤ 18，m < n×n ），接下来m行，每行三个整数u、v和w，
// 表示顶点u和v之间有一条权值为w的边相连。
//（ 1 ≤ u < v ≤ n，w ≤ 1000 ）。假设起点（驻地）为1号顶点。
//Output
//对应每个测试样例输出一行，格式为"Case #: W"，其中'#'表示第几个测试样例（从1开始计），W为TSP问题的最优解，如果找不到可行方案则输出-1。
//Sample Input
//2
//5 8
//1 2 5
//1 4 7
//1 5 9
//2 3 10
//2 4 3
//2 5 6
//3 4 8
//4 5 4
//3 1
//1 2 10
//
//Sample Output
//Case 1: 36
//Case 2: -1



#include<stdio.h>
#include<minmax.h>

#define INF 100000000

int cost[18][18];
int dp[1<<18][18];

//取最小值(注意：这里取二者最小值，之前的题目是比较排序compare——从小到大或者从大到小，需要用到内置函数qsort)
//int min(int a, int b){
//    return a > b ? b : a;
//}

int main(){
    int T;
    scanf("%d",&T);//输入测试用例
    for(int t = 1; t <= T;t++){
        int n,m,u,v,w;
        scanf("%d%d",&n,&m);//输入顶点个数和边个数
        for(int i = 0;i < m; i++)
            for(int j = 0;j < n;j++)  //首先初始化cost数组为无穷大，表示从i到j的花费
                cost[i][j] = (i == j) ? 0 :INF;//所有边初始化为无穷大（顶点相等除外，因为自己到自己距离为0）

        for(int i = 0;i < m; i++){
            scanf("%d%d%d",&u,&v,&w);//输入两个顶点和之间的边权重
        v--;//顶点从0开始，所以全部减一
        u--;//顶点从0开始，所以全部减一
        if(cost[u][v] > w)  //如果边权重 小于 两顶点之间的花费
            cost[u][v] = cost[v][u] = w;//将边权重赋值给两顶点之间的花费
        }
        int N = (1<<n);//初始化包含n个状态的N（通过二进制存储）
        for(int s = 0; s < N;s++){ //状态s从0开始遍历
            for(int i = 0; i < n;i++){ //顶点从0开始遍历
                dp[s][i] = INF; //初始化dp数组为无穷大，dp数组表示在状态s下从顶点0出发到顶点i的最小花费
            }
        }
        dp[1][0] = 0; //***要为顶点特别初始化0到0花费为0
        for(int s = 1; s < N;s++) { //状态s从1开始，到N-1结束
            for (int i = 0; i < n; i++) { //顶点从0开始遍历
                if (!(s & (1 << i)))  //如果顶点i没有访问过（s与运算1<<i结果是i的状态，如果未访问顶点i，则跳过顶点i）
                    continue;  //跳过顶点1,访问顶点i的之前的所有顶点j

                for (int j = 0; j < n; j++) { //遍历顶点i的之前的所有顶点j，找出到达i最小花费
                    if (cost[j][i] < INF && i != j && s & (1 << j)) { //j已访问且j不等于i,且j到i有路
                        //比较不同的j到达i的花费，找出最小花费的顶点j
                        dp[s][i] = min(dp[s][i], dp[s ^ (1 << i)][j] + cost[j][i]);//（s^(1<<i)异或运算，不同为1，相同为0）
                                                                                //最终可以获取剔除顶点i之后的顶点j的访问状态
                    }
                }
            }
        }
    int ans = INF; //将最终答案（旅行最小花费）初始化为无穷大
    for(int i = 1; i < n;i++){ //从第二个顶点开始遍历
        if(cost[i][0] < ans){ //如果顶点i回到0的花费小于ans
            ans = min(ans,dp[N-1][i] + cost[i][0]); //比较ans 与 从0到i再从i回到0的花费，取较小值
        }
    }
        printf("Case %d: %d\n",t,ans == INF ? -1 : ans); //打印输出测试用例t下的旅行最小花费
    }
    return 0;
}









//#include<stdio.h>
//
//#define INF 100000000
//int cost[18][18];
//int dp[1<<18][18];
//
//int min(int a,int b){
//    return a > b ? b : a;
//}
//
//int main(){
//    int T;//输入测试用例个数
//    scanf("%d",&T);
//    for(int t = 1 ; t <= T; t++){
//        int n,m,u,v,w;
//        scanf("%d%d",&n,&m);
//        for(int i = 0; i < m; i++){
//            for(int j = 0; j < n; j++){
//                cost[i][j] = (i==j) ? 0 : INF;
//            }
//        }
//        for(int i = 0; i < m;i++){
//            scanf("%d%d%d",&u,&v,&w);
//            u--;
//            v--;
//            if(cost[u][v] > w){
//                cost[u][v] = cost[v][u] = w;
//            }
//        }
//        int N = (1<<n);
//        for(int s = 0; s < N;s++){
//            for(int i = 0; i < n; i++){
//                dp[s][i] = INF;
//            }
//        }
//        dp[1][0] = 0; //初始化0到0的dp数组花费为0
//        for(int s = 1; s < N; s++){
//            for(int i = 0; i < n; i++){
//                if(!(s & (1 << i)))
//                    continue;
//
//                for(int j = 0; j < n; j++){
//                    if(cost[j][i] < INF && i != j && s &(1<<j)){
//                        dp[s][i] = min(dp[s][i],dp[s^(1<<i)][j] + cost[j][i]);
//                    }
//                }
//            }
//        }
//        int ans = INF;
//        for(int i = 1; i < n; i++){ //从第二个顶点开始遍历
//            if(cost[i][0] < ans){
//                ans = min(ans, dp[N-1][i] + cost[i][0]);
//            }
//        }
//        printf("Case %d: %d\n",t,ans == INF ? -1 : ans);
//    }
//    return 0;
//}
//






//#include<stdio.h>
//#define INF 100000000
//int cost[18][18];
//int dp[1<<18][18];
//
//int min(int a,int b){
//    return a > b ? b : a;
//}
//
//int main(){
//    int T;
//    scanf("%d",&T);
//    for(int t = 1; t <= T;t++){
//        int n,m,u,v,w;
//        scanf("%d%d",&n,&m);
//        for(int i=0;i<m;i++){
//            for(int j=0;j<n;j++){
//                cost[i][j] = (i==j) ? 0 : INF;
//            }
//        }
//        for(int i =0;i<m;i++){
//        scanf("%d%d%d",&u,&v,&w);
//        u--;
//        v--;
//        if(cost[u][v] > w){
//            cost[u][v] = cost[v][u] = w;
//        }
//        }
//        int N = 1<<n;
//        for(int s = 0; s < N;s++){
//            for(int i = 0;i<n;i++){
//                dp[s][i] = INF;
//            }
//        }
//        dp[1][0] = 0;
//    for(int s =1;s < N;s++){
//        for(int i = 0; i < n; i++){
//            if(!(s & (1<<i)))
//                continue;
//
//            for(int j = 0;j<n;j++){
//                if(cost[j][i] < INF && i != j && s &(1<<j)){
//                    dp[s][i] = min(dp[s][i],dp[ s ^ (1<<i)][j] + cost[j][i]);
//                }
//            }
//        }
//    }
//    int ans = INF;
//    for(int i =1; i< n; i++){
//        if(cost[i][0] < ans){
//            ans = min(ans,dp[N-1][i] + cost[i][0]);
//        }
//    }
//    printf("Case %d: %d\n",t,ans == INF ? -1 :ans);
//    }
//    return 0;
//}






































//#include <stdio.h>
//#define INF 100000000 // 定义一个足够大的数，表示不可达或无穷大
//
//int cost[18][18], dp[1<<18][18]; // cost[i][j]存储i到j的最小花费，dp[s][i]表示状态s下最后在i的最小花费,状态s位数最大18,2^18
//
//int min(int a, int b) { return a < b ? a : b; } // 求两个数的较小值
//
//int main() {
//    int T, n, m, u, v, w; // T:测试组数 n:城市数 m:边数 u,v:边的两端 w:权值
//    scanf("%d", &T); // 读入测试组数
//    for (int t = 1; t <= T;t++) { // 对每组测试
//        scanf("%d%d", &n, &m); // 读入城市数和边数
//        for (int i = 0; i < n; i++) // 初始化cost数组
//            for (int j = 0; j < n; j++)
//                cost[i][j] = (i == j) ? 0 : INF; // 遍历初始化cost数组,自己到自己为0，其它为INF
//        for (int i = 0; i < m; i++) { // 读入每条边
//            scanf("%d%d%d", &u, &v, &w); // 读入边的两个端点和权值
//            u--; v--; // 下标从0开始,所以要减一
//            if (w < cost[u][v]) cost[u][v] = cost[v][u] = w; // 取最小权值，双向边
//        }
//        int N = 1 << n; // N为所有状态的总数（2^n）
//        for (int s = 0; s < N; s++) // 初始化dp数组
//            for (int i = 0; i < n; i++)
//                dp[s][i] = INF; // 所有状态初始为INF
//        dp[1][0] = 0; // 只访问了城市0（起点），花费为0,实际上，判断城市i是否已访问，是要是看1<<i(2^i)
//        for (int s = 1; s < N; s++) { // 枚举所有状态s
//            for (int i = 0; i < n; i++) { // 枚举最后停在城市i
////                s & (1 << i)进行二进制与运算:全1为1，其余为0
////                假设 i = 2，1 << 2 的结果是 0b100（十进制 4）：
////                如果状态 s = 0b1010（十进制 10），那么 s & (1 << 2) 等于 0b1000 & 0b1010 = 0b1000（非零），表示城市2被访问过。
////                如果状态 s = 0b0010（十进制 2），那么 s & (1 << 2) 等于 0b1000 & 0b0010 = 0b0000（零），表示城市2未被访问。
//
//                if (!(s & (1 << i))) continue; // 如果i没被访问，跳过，
//                for (int j = 0; j < n; j++) { // 枚举上一个城市j
//                    if (s & (1 << j) && i != j && cost[j][i] < INF) // 如果j已访问且不是i本身且j到i有路
////                        s ^ (1 << i)进行异或运算：不同为1，相同为0
//                        dp[s][i] = min(dp[s][i], dp[s ^ (1 << i)][j] + cost[j][i]);
////                    s ^ (1 << i) 表示把当前状态 s 中的城市 i 去掉（就像把旅行日志里「已访问城市列表」的第i项划掉）
////                    此时你在上一状态中最后停留在城市 j 的花费
//                    // 状态转移：从j到i，更新最小花费
//                }
//            }
//        }
//        int ans = INF; // 最优解初始化为INF
//        for (int i = 1; i < n; i++) // 枚举最后一个城市（不能是起点）
//            if (cost[i][0] < INF)
////                当s=N-1（二进制全1）时表示访问过所有城市，也就是所有城市的状态
////                枚举所有可能的终点i，计算返回起点的最小花费：
//                ans = min(ans, dp[N-1][i] + cost[i][0]); // 回到起点，更新最小花费
//        printf("Case %d: %d\n", t, ans == INF ? -1 : ans); // 输出结果，若无解输出-1
//    }
//    return 0;
//}

//代码实现逻辑说明
//输入与初始化
//读入测试组数T。
//对每组测试，读入城市数n和边数m。
//初始化cost数组，cost[i][j]表示城市i到j的最小花费，初始为INF（不可达），自己到自己为0。
//读入每条边，更新cost数组，保证存储最小权值。
//状态压缩DP初始化
//N = 1 << n = 2^n，表示所有城市访问状态的总数（2^n）,每个城市分为已访问和未访问。
//dp[s][i]表示状态s下，最后停在城市i的最小花费。*****
//所有dp初始为INF，dp[1][0]=0表示只访问了起点0，花费为0。也就是访问0城市（起点）的最小花费
//状态转移
//枚举所有状态s（哪些城市被访问过），再枚举最后停在城市i。
//如果i在s中被访问过，则枚举上一个城市j（j也在s中且j≠i且j到i有路），
//状态转移：dp[s][i] = min(dp[s][i], dp[s ^ (1 << i)][j] + cost[j][i])，即从j到i的最小花费。
//答案计算
//枚举最后一个城市i（不能是起点），如果i能回到起点，则ans = min(ans, dp[N-1][i] + cost[i][0])。
//若ans仍为INF，说明无解，输出-1，否则输出最小花费。
//如何理解实现逻辑
//状态压缩：用一个整数的二进制位表示哪些城市被访问过（如s=1011表示0、1、3被访问，从右往左）。状态压缩指的是将城市是否访问状态压缩成二进制表示，二进制每一位代表一个城市
//动态规划：dp[s][i]表示从起点出发，经过状态s（即访问了s中的所有城市），最后停在i的最小花费。
//状态转移：从一个较小的状态（少访问一个城市）转移到当前状态，枚举上一个城市j，累加j到i的花费。
//最终答案：所有城市都访问过（s=N-1=2^n-1），最后回到起点0的最小花费。
//这种方法利用了TSP的最优子结构和重叠子问题特性，将指数级的排列问题降为O(n²·2ⁿ)的复杂度，适合n≤18的情况。
//如果某些城市不可达或无法成环，最终会输出-1。

//疑惑点解析：
//在状态压缩中的具体作用：
//生成掩码 1 << i 会生成一个只有第 i 位为 1 的二进制数，用来标记某个特定城市是否被访问过。
//例如：1 << 3 生成 0b1000（二进制），表示城市3被访问过。
//检查状态 通过 s & (1 << i) 可以判断城市 i 是否在状态 s 中被访问过：
//如果结果为非零，说明第 i 位是 1（城市被访问过）。
//如果结果为零，说明第 i 位是 0（城市未被访问）。
//构建状态 通过 s | (1 << i) 可以将城市 i 标记为已访问（将第 i 位置为 1）。
//举个例子：
//假设 i = 2，1 << 2 的结果是 0b100（十进制 4）：
//如果状态 s = 0b1010（十进制 10），那么 s & (1 << 2) 等于 0b1000 & 0b1010 = 0b1000（非零），表示城市2被访问过。
//如果状态 s = 0b0010（十进制 2），那么 s & (1 << 2) 等于 0b1000 & 0b0010 = 0b0000（零），表示城市2未被访问。
//为什么用这种方式？
//高效：位运算的速度极快，比数组或哈希表更节省时间和空间。
//简洁：用一个整数就能表示所有城市的访问状态。
//兼容性：C/C++ 直接支持位运算，适合底层优化。
//类比理解：
//想象你有一个开关板，上面有 n 个开关，每个开关控制一个城市的灯：
//1 << i 相当于只打开第 i 个开关的单灯模式。
//s & (1 << i) 相当于检查第 i 个开关是否处于开启状态。

//核心位运算
//检查城市i是否访问：s & (1 << i)【与运算：全1为1，其余为0】
//1 << i 生成只有第i位为1的掩码
//按位与操作可检测对应位是否为1
//添加城市i到访问集合：s | (1 << i)【或运算：全0为0，其余为1】
//移除城市i：s & ~(1 << i)【取反运算：0变1,1变0】
//切换城市i状态：s ^ (1 << i)【异或运算：不同为1，相同为0】


//疑惑点解析：
//1. dp[s][i] 是什么？
//这是你「旅行日志」中记录的当前状态：
//状态 s 表示你已经访问过的城市集合（比如 s=1011 表示访问过城市0、1、3）
//当前站在城市 i 的花费
//2. dp[s ^ (1 << i)][j] 是什么？
//这是「上一状态」的花费：
//s ^ (1 << i) 表示把当前状态 s 中的城市 i 去掉（就像把旅行日志里「已访问城市列表」的第i项划掉）
//此时你在上一状态中最后停留在城市 j 的花费
//3. cost[j][i] 是什么？
//这是从城市 j 直接到城市 i 的花费（就像地图上标记的两点之间的路费）
//4. min(...) 在做什么？
//比较两个选项的花费：
//原方案：当前记录的 dp[s][i] 花费
//新方案：从 j 城市「跳转」到 i 的总花费（上一状态的花费 + 新增路费）
//保留更便宜的那个方案
//举个具体例子
//假设我们有4个城市（0,1,2,3），当前状态 s=1011（二进制）表示已访问过城市0、1、3，现在站在城市3（i=3）：
//s ^ (1 << i) 会变成 1011 ^ 1000 = 0011，表示「去掉城市3后的状态」（只访问过0、1）
//dp[0011][j] 会遍历 j=0 和 j=1（因为只有这两个城市在去掉3后被访问过）
//计算：
//如果从城市1（j=1）走到3，花费是 dp[0011][1] + cost[1][3]
//如果从城市0（j=0）走到3，花费是 dp[0011][0] + cost[0][3]
//最终 dp[1011][3] 会取这两个选项中的最小值
//为什么这样设计？
//最优子结构：要得到当前状态的最优解，必须先知道所有可能的「上一状态」最优解
//状态压缩：通过位运算快速切换状态（就像开关控制灯泡）
//动态规划：从小规模问题逐步构建大问题的解（先解决访问1个城市，再解决访问2个...）
//类比理解
//想象你在玩闯关游戏：
//每个关卡（状态s）需要收集钥匙（城市i）
//你知道前面所有关卡的通关时间（dp[s ^ (1<<i)][j]）
//现在要计算带着新钥匙通关的时间（dp[s][i]）
//你会比较所有可能的「上一关卡」加上「当前关卡耗时」，取最短时间