//
// Created by 王智杰 on 2025/6/14.
//
//42.活动安排问题（贪心算法）**

//Description
//设有n个活动的集合E={1, 2, ..., n}，其中，每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。
//每个活动i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi ，且si < fi。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。
//若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。
//活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。
//Input
//输入的第一个为测试样例的个数T，接下来有T个测试样例。
//每个测试样例的第一行是一个整数n（ n ≤ 1000 ），表示有n个活动。
//接下来n行，每行两个整数 si 和 fi 表示第 i 个活动的起始时间和结束时间。
//Output
//对应每个测试样例输出一行，格式为"Case #: D"，其中'#'表示第几个测试样例（从1开始计），D为最大的相容活动子集合的活动数量。
//Sample Input
//1
//11
//1 4
//3 5
//0 6
//5 7
//3 8
//5 9
//6 10
//8 11
//8 12
//2 13
//12 14

//Sample Output
//Case 1: 4


#include <stdio.h>
#include <stdlib.h>
#include <minmax.h>

int cmp(const void *a,const void *b){
    return ((int *)a)[0] - ((int *)b)[0];//按照左边界从小到大排序
}

int main(){
    int T;
    scanf("%d",&T);//输入测试用例个数
    for(int t = 1; t <= T; t++){
        int n;
        scanf("%d",&n);//输入活动个数
        int nums[1005][2];//定义二维数组
        if(n == 0){ //如果活动个数为0，直接打印返回结果，进入下一个测试用例
            printf("Case %d: 0\n",t);
            continue;  // 跳过当前循环
        }
        for(int i = 0; i < n; i++){
            scanf("%d %d",&nums[i][0],&nums[i][1]);//输入每个活动的起始时间和结束时间
        }
        //使用内置排序函数qsort将活动的起始时间从小到大进行排序（左边界排序）
        qsort(nums,n,sizeof(int *),cmp);
        int count = 0;//记录重叠的区间个数
        for(int i = 1; i < n; i++){ //从第二个为活动开始，与前一个活动比较
            if(nums[i][0] < nums[i-1][1]){ //如果当前活动开始时间小于前一个活动结束时间，重叠区间个数count++
                count++;
                nums[i][1] = min(nums[i][1],nums[i-1][1]);//将当前活动的结束时间重新赋值，取与前一个活动相比的较小值
                //因为当前活动的结束时间需要与后一个活动的开始时间相比较的
            }
        }
        printf("Case %d: %d\n",t ,n - count);//打印输出活动总数 - 重叠区间活动个数 = 最大相容活动个数
    }
    return 0;
}