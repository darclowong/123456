//
// Created by 王智杰 on 2025/6/14.
//
//8.矩阵连乘（DP）**
//
//Description
//给定n个矩阵{ A1，A2，…，An }，保证Ai与Ai+1是可乘的，i = 1，2，…，n-1。考察这n个矩阵的连乘积A1A2…An。
//由于矩阵乘法满足结合律，故计算矩阵的连乘积可以有许多不同的计算次序。
//这种计算次序可以用加括号的方式来确定。现要求设计一个高效的算法，对给定的n个矩阵确定一个计算次序使得总的乘法次数最少，并输出该最优值。
//Input
//输入的第一行是单独一个整数T，表示案例的数目。每个案例的第一行是单独一个n ( 1 ≤ n ≤ 600 )，表示矩阵的个数。
//接下来第n行，依序分别对应第i个矩阵，每行包括两个整数xi，yi (1 ≤ i ≤ n，1 ≤ xi , yi ≤ 100 )，表示该矩阵的行数和列数。保证n个矩阵依序是可乘的。
//Output
//每个案例输出一个整数，表示最少需要的乘法次数。 运算过程及结果不会超出int范围。
//Sample Input
//1
//4
//50 10
//10 40
//40 30
//30 5
//
//Sample Output
//10500

#include <stdio.h>
#define MAX_N 601
#define INF 100000000

int p[MAX_N];         // 全局变量：存储矩阵维度：p[0]=A1行, p[1]=A1列/A2行, p[2]=A2列/A3行, ..., p[n]=An列
int dp[MAX_N][MAX_N]; // dp[i][j] = 计算 Ai..Aj 的最小乘法次数
int s[MAX_N][MAX_N];  // s[i][j] = Ai..Aj 的最优划分位置

int main() {
    int T;
    scanf("%d", &T);//输入测试用例个数

    while (T--) {
        int n;  //矩阵个数
        scanf("%d", &n);//输入矩阵个数

        // 读取矩阵维度 (第一个矩阵需要行和列)
        scanf("%d %d", &p[0], &p[1]);

        // 读取后续矩阵 (只需要列，因为行等于前一个矩阵的列)
        for (int i = 1; i < n; i++) {
            int x, y;//定义矩阵的行和列
            scanf("%d %d", &x, &y);//输入第二个矩阵开始的行和列
            p[i + 1] = y;  // 保存当前矩阵的列
        }

        // 初始化：单个矩阵乘法次数为0
        for (int i = 1; i <= n; i++) {
            dp[i][i] = 0; //单个矩阵的最小连乘次数为0
            s[i][i] = i;  // 单个矩阵的最优划分位置是自身
        }

        // 动态规划：按区间长度从小到大计算
        for (int len = 2; len <= n; len++) {  // 区间长度从2到n
            for (int i = 1; i <= n - len + 1; i++) {  // 区间起始点
                int j = i + len - 1;  // 区间结束点
                dp[i][j] = INF;  // dp数组初始化为无穷大

                // 四边形不等式优化：确定k的搜索范围
                int k0 = s[i][j - 1];    // 左边界
                int k1 = s[i + 1][j];    // 右边界：左边界+1
                if (len == 2) {          // 特判：两个矩阵的情况
                    k0 = i;  //左边界
                    k1 = i;  //右边界
                }

                // 在优化范围内搜索最优划分点k
                for (int k = k0; k <= k1 && k < j; k++) {
                    // 计算划分点k处的乘法次数
                    int cost = dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j];

                    // 更新最优解
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;  //记录i,j最小乘连乘次数
                        s[i][j] = k;  // 记录最优划分位置
                    }
                }
            }
        }
        // 输出A1..An的最小乘法次数（dp[1][n]表示1到n的最佳乘法次数）
        printf("%d\n", dp[1][n]);
    }
    return 0;
}


//逻辑思路
//1.定义三个全局数组
//2.输入测试用例数和矩阵个数维数（行与列）
//3.特殊处理单个矩阵的情况
//4.遍历初始化dp数组为无穷大（从len为2开始）
//5.初始化k1和k0，特殊处理len为2的情况
//6.使用k0和k1作为for循环条件